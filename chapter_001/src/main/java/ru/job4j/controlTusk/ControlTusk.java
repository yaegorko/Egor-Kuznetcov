package ru.job4j.controltusk;

/**
 * Класс ControlTusk для задания "Проверка, что одно слово находится в другом слове".
 * @author - Egor K.
 * @since - 25.08.17
 */

public class ControlTusk {
    /**
     * Метод contains проверяющий вхождение строки sub в строку origin.
     * @param origin строка в которой ищем вхождение строки sub.
     * @param sub подстрока которую ищем в строке origin.
     * @return true - нашли вхождение, false - строка не входит.
     */

    boolean contains(String origin, String sub) {

        char[] originChar = origin.toCharArray(); // исходная строка в исходный массив char
        char[] subChar = sub.toCharArray(); // подстрока в массив char


//        for (int i = 0; i < originChar.length; i++) {  // перебираем массив исходной строки
//            for (int j = 0; j < subChar.length; j++) { // перебираем массив подстроки
//                   if (originChar[i] == subChar[j]) {  // сравниваем элементы массивов, ищем вхождение (можно же искать только первый символ, переписываю...)
//                       for (int x = 0; x < subChar.length; x++) { // перебираем элементы обоих массивов на расстоянии подстроки от первого совпадения эл-тов
//                           if (originChar[i + x] == subChar[x]) { // сравниваем соответствующие эл-ты обоих массивов
//                               if (x == subChar.length - 1) {     // если количество одинаковых эл-тов в обоих массивах равно длине массива подстроки
//                                   marker = true;                 // мы нашли построку в строке
//                                   return marker;                 // вернули тру
//                               }
//                           } else break;  //прерываем проверку данной последовательности текущие эл-ты на расстоянии подстроки не равны
//                       }
//                   }
//            }
//        }
        for (int i = 0; i < originChar.length; i++) {        // перебираем массив исходной строки
            if (subChar[0] == originChar[i]) {               // ищем совпадение первого символа подстроки с символом исходной строки, точку входа.
                for (int j = 0; j < subChar.length; j++) {   // перебираем массив подстроки
                    try {
                        if (subChar[j] == originChar[i + j]) {   // сравниваем э-ты двух массивов на расстоянии длины массива подстроки
                            if (j == subChar.length - 1) {       // если они равны на всей длине - мы нашли подстроку в строке!!1
                                return true;                     // возвращаем тру.
                            }
                        } else {
                            break;                                  // прерываем проверку данной последовательности, текущие э-лты не равны,
                        }                                           // дальнейшая проверка текущего вхождения бессмыслена.

                    }  catch (ArrayIndexOutOfBoundsException x) {   // точка входа находится находится ближе к концу исходной строки, чем длина подстроки.
                        return false;                               // строка не содержит подстроку.
                        }
                }
            }
        }

        return false;                                        // строка не содержит подстроку.
    }
}
